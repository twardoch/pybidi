Project Structure:
📁 pybidi
├── 📄 CHANGELOG.md
├── 📄 fribidi.py
├── 📄 PLAN.md
├── 📄 README
├── 📄 REFACTOR_FILELIST.txt
├── 📄 setup.py
└── 📄 TODO.md


<documents>
<document index="1">
<source>CHANGELOG.md</source>
<document_content>
# Changelog

## Recent Changes

### 2025-06-25
- **Auto-merge**: Resolved conflicts from merge operations

### 2023-09-27
- **Project Relocation**: Project moved to other repositories (GitLab and Bitbucket)
- **Documentation Update**: Updated README with new repository locations
  - GitLab: https://gitlab.com/ldo/pybidi
  - Bitbucket: https://bitbucket.org/ldo17/pybidi

### 2022-07-24
- **Bug Fix**: Added missing qualification where needed

### 2022-05-30
- **Build System Update**: Switched from the soon-to-be-obsoleted distutils to the recommended setuptools for building and installation

### Earlier Updates
- Fixed typos in documentation
- Bumped version and added setup.cfg
- Changed URL references to use HTTPS
- Code formatting improvements (broke up long lines)

## About PyBidi

PyBidi is a Python 3 binding for the FriBidi library, which implements the Unicode Bidirectional Algorithm for handling right-to-left and mixed-direction text. The library provides comprehensive support for:

- Bidirectional text reordering
- Arabic text shaping
- Character mirroring
- Joining type detection
- Multiple character set conversions
</document_content>
</document>

<document index="2">
<source>PLAN.md</source>
<document_content>
# PyBidi Improvement Plan

## Current State Analysis

PyBidi is a Python 3 binding for the FriBidi library, providing Unicode bidirectional text algorithm support. The project appears to be in maintenance mode, with a note indicating it has moved to other repositories. However, there are significant opportunities to modernize and improve the codebase.

## Key Areas for Improvement

### 1. Modern Python Packaging and Build System

#### Current Issues:
- Using legacy setup.py with minimal configuration
- No pyproject.toml file (PEP 517/518 compliance)
- No proper dependency management
- Version is hardcoded in setup.py

#### Proposed Solutions:
- Migrate to pyproject.toml with proper build system configuration
- Use setuptools with declarative configuration
- Implement proper version management (possibly using setuptools_scm)
- Add proper metadata including long description, classifiers, and URLs
- Consider using Poetry or Hatch for modern dependency management

### 2. Type Safety and Modern Python Features

#### Current Issues:
- No type annotations throughout the codebase
- Using old-style string formatting
- No use of modern Python features (dataclasses, enums, etc.)
- Manual memory management with ctypes without proper safety checks

#### Proposed Solutions:
- Add comprehensive type hints using typing module
- Create type stubs (.pyi files) for better IDE support
- Use Enum for constants instead of class attributes
- Implement proper error types instead of generic RuntimeError
- Add mypy configuration for static type checking
- Use dataclasses for structured data where appropriate

### 3. Error Handling and Library Loading

#### Current Issues:
- Basic platform detection for library loading
- No fallback mechanisms if library is not found
- No clear error messages for missing dependencies
- Limited error handling in ctypes calls

#### Proposed Solutions:
- Implement robust library detection with multiple search paths
- Add clear installation instructions for each platform
- Create a compatibility layer that handles different FriBidi versions
- Add proper exception hierarchy with informative error messages
- Implement retry mechanisms and fallbacks where appropriate

### 4. Testing Infrastructure

#### Current Issues:
- No test suite exists
- No continuous integration setup
- No code coverage metrics
- No performance benchmarks

#### Proposed Solutions:
- Create comprehensive test suite using pytest
- Add unit tests for all public APIs
- Implement integration tests with actual FriBidi library
- Add property-based testing using Hypothesis
- Set up GitHub Actions for CI/CD
- Configure code coverage with codecov
- Add performance benchmarks for critical operations

### 5. Documentation

#### Current Issues:
- Minimal README file
- No API documentation
- No usage examples
- No contribution guidelines

#### Proposed Solutions:
- Create comprehensive README with badges, installation, and usage
- Add Sphinx-based documentation
- Generate API documentation from docstrings
- Create tutorial notebooks with Jupyter
- Add examples directory with common use cases
- Write contribution guidelines and code of conduct

### 6. Code Quality and Maintainability

#### Current Issues:
- Large monolithic fribidi.py file (1500+ lines)
- Mixed concerns (low-level bindings with high-level API)
- Inconsistent coding style
- No linting or formatting configuration

#### Proposed Solutions:
- Split code into logical modules:
  - `core.py`: Core ctypes bindings
  - `constants.py`: FriBidi constants and enums
  - `types.py`: Type definitions and data structures
  - `api.py`: High-level Python API
  - `utils.py`: Utility functions
- Configure black for code formatting
- Set up flake8/ruff for linting
- Add pre-commit hooks for consistency
- Implement proper logging instead of print statements

### 7. Platform Support and Distribution

#### Current Issues:
- Manual platform detection
- No wheel distribution
- No conda package
- Unclear system requirements

#### Proposed Solutions:
- Create platform-specific wheels
- Add conda-forge recipe
- Support more platforms (including ARM architectures)
- Create Docker images for testing
- Add clear system requirements documentation
- Consider bundling FriBidi library or using cibuildwheel

### 8. API Improvements

#### Current Issues:
- Low-level API requires understanding of FriBidi internals
- No convenient high-level functions for common tasks
- Inconsistent naming conventions
- No async support where beneficial

#### Proposed Solutions:
- Create high-level API wrapper with intuitive methods
- Add convenience functions for common operations
- Implement context managers where appropriate
- Add builder pattern for complex operations
- Consider async support for batch processing

### 9. Security and Safety

#### Current Issues:
- Direct ctypes usage without bounds checking
- Potential buffer overflows in string handling
- No input validation

#### Proposed Solutions:
- Add comprehensive input validation
- Implement safe string handling with proper bounds checking
- Add security policy documentation
- Regular dependency updates
- Consider using CFFI instead of ctypes for better safety

### 10. Community and Maintenance

#### Current Issues:
- Project marked as moved to other repositories
- Unclear maintenance status
- No community engagement

#### Proposed Solutions:
- Clarify project status and future direction
- Set up GitHub Discussions for community engagement
- Create issue templates for bugs and features
- Establish clear governance model
- Consider moving to a community organization
- Set up GitHub Sponsors or Open Collective for funding

## Implementation Priority

1. **High Priority** (Essential for modernization):
   - Modern packaging (pyproject.toml)
   - Basic test suite
   - Type annotations
   - Improved error handling

2. **Medium Priority** (Significant improvements):
   - Code refactoring into modules
   - Documentation
   - CI/CD setup
   - Platform wheels

3. **Low Priority** (Nice to have):
   - Advanced API features
   - Performance optimizations
   - Additional platform support
   - Community features

## Migration Strategy

To avoid breaking existing users while implementing these improvements:

1. Create a new major version (1.0) with the improvements
2. Maintain backward compatibility where possible
3. Provide migration guide for breaking changes
4. Offer legacy module for old API compatibility
5. Deprecate old patterns gradually with clear warnings

## Success Metrics

- Test coverage > 90%
- Type coverage 100%
- Documentation coverage 100%
- Successful builds on Windows, macOS, Linux
- Package available on PyPI with wheels
- Active community engagement
- Regular release cycle established
</document_content>
</document>

<document index="3">
<source>README</source>
<document_content>
This project is no longer being maintained on GitHub.
Look for it at one of
* gitlab: https://gitlab.com/ldo/pybidi
* bitbucket: https://bitbucket.org/ldo17/pybidi

</document_content>
</document>

<document index="4">
<source>REFACTOR_FILELIST.txt</source>
<document_content>
55	./llms.txt
52	./fribidi.py
7	./PLAN.md
3	./TODO.md

</document_content>
</document>

<document index="5">
<source>TODO.md</source>
<document_content>
# PyBidi TODO List

## Immediate Tasks (High Priority)

### Packaging and Build
- [ ] Create pyproject.toml with modern build configuration
- [ ] Update setup.py to use setuptools properly
- [ ] Add proper package metadata and classifiers
- [ ] Configure version management (consider setuptools_scm)
- [ ] Add MANIFEST.in for non-Python files

### Type Safety
- [ ] Add type annotations to all functions in fribidi.py
- [ ] Create py.typed marker file
- [ ] Add mypy configuration
- [ ] Generate type stubs for better IDE support
- [ ] Run mypy in strict mode and fix all issues

### Testing
- [ ] Set up pytest framework
- [ ] Create tests/ directory structure
- [ ] Write unit tests for core functionality
- [ ] Add integration tests for library loading
- [ ] Configure GitHub Actions for CI
- [ ] Set up code coverage reporting

### Documentation
- [ ] Write comprehensive README.md to replace README
- [ ] Add installation instructions for all platforms
- [ ] Create examples/ directory with usage examples
- [ ] Add inline documentation to all public APIs
- [ ] Set up Sphinx documentation

## Short-term Tasks (Medium Priority)

### Code Quality
- [ ] Split fribidi.py into logical modules
- [ ] Set up black for code formatting
- [ ] Configure ruff or flake8 for linting
- [ ] Add pre-commit hooks
- [ ] Remove or update deprecated code patterns

### Error Handling
- [ ] Improve library loading with better error messages
- [ ] Add fallback mechanisms for missing libraries
- [ ] Create custom exception classes
- [ ] Add input validation for all public functions
- [ ] Implement proper logging instead of print statements

### Platform Support
- [ ] Test on Windows, macOS, and Linux
- [ ] Create platform-specific installation guides
- [ ] Build wheels for major platforms
- [ ] Add ARM architecture support
- [ ] Consider using cibuildwheel for releases

## Long-term Tasks (Low Priority)

### API Improvements
- [ ] Design high-level convenience API
- [ ] Add context managers where appropriate
- [ ] Implement builder pattern for complex operations
- [ ] Create async support for batch operations
- [ ] Add streaming support for large texts

### Distribution
- [ ] Publish to PyPI with wheels
- [ ] Create conda-forge recipe
- [ ] Set up automated releases
- [ ] Create Docker images for testing
- [ ] Consider bundling FriBidi library

### Community
- [ ] Add CONTRIBUTING.md guidelines
- [ ] Create issue templates
- [ ] Set up GitHub Discussions
- [ ] Add CODE_OF_CONDUCT.md
- [ ] Create security policy

### Performance
- [ ] Add performance benchmarks
- [ ] Optimize memory usage
- [ ] Consider using CFFI instead of ctypes
- [ ] Profile and optimize hot paths
- [ ] Add caching where beneficial

## Maintenance Tasks

### Regular Updates
- [ ] Update dependencies regularly
- [ ] Monitor security advisories
- [ ] Review and merge community PRs
- [ ] Maintain changelog
- [ ] Tag releases properly

### Quality Assurance
- [ ] Achieve >90% test coverage
- [ ] Fix all type checking issues
- [ ] Ensure all functions are documented
- [ ] Regular code review
- [ ] Performance regression tests
</document_content>
</document>

# File: /Users/adam/Developer/vcs/github.twardoch/pub/pybidi/fribidi.py
# Language: python

import ctypes as ct
import sys

class FRIBIDI:
    """useful definitions adapted from fribidi/*.h. You will need to use the constants and “macro” function..."""
    def LEVEL_IS_RTL((lev)):
        """Is right-to-left level?"""
    def LEVEL_TO_DIR((lev)):
        """returns the bidi type corresponding to the direction of the level number."""
    def DIR_TO_LEVEL((dir)):
        """returns the minimum level of the direction, 0 for FRIBIDI.TYPE_LTR and1 for FRIBIDI.TYPE_RTL and FRI..."""
    def IS_RTL((p)):
        """Is right to left: RTL, AL, RLE, RLO?"""
    def IS_ARABIC((p)):
        """Is arabic: AL, AN?"""
    def IS_STRONG((p)):
        """Is strong?"""
    def IS_WEAK((p)):
        """Is weak?"""
    def IS_NEUTRAL((p)):
        """Is neutral?"""
    def IS_SENTINEL((p)):
        """Is sentinel?"""
    def IS_LETTER((p)):
        """Is letter: L, R, AL?"""
    def IS_NUMBER((p)):
        """Is number: EN, AN?"""
    def IS_NUMBER_SEPARATOR_OR_TERMINATOR((p)):
        """Is number separator or terminator: ES, ET, CS?"""
    def IS_SPACE((p)):
        """Is space: BN, BS, SS, WS?"""
    def IS_EXPLICIT((p)):
        """Is explicit mark: LRE, RLE, LRO, RLO, PDF?"""
    def IS_SEPARATOR((p)):
        """Is text separator: BS, SS?"""
    def IS_OVERRIDE((p)):
        """Is explicit override: LRO, RLO?"""
    def IS_LTR_LETTER((p)):
        """Is left to right letter: LTR?"""
    def IS_RTL_LETTER((p)):
        """Is right to left letter: RTL, AL?"""
    def IS_ES_OR_CS((p)):
        """Is ES or CS: ES, CS?"""
    def IS_EXPLICIT_OR_BN((p)):
        """Is explicit or BN: LRE, RLE, LRO, RLO, PDF, BN?"""
    def IS_EXPLICIT_OR_BN_OR_NSM((p)):
        """Is explicit or BN or NSM: LRE, RLE, LRO, RLO, PDF, BN, NSM?"""
    def IS_EXPLICIT_OR_BN_OR_WS((p)):
        """Is explicit or BN or WS: LRE, RLE, LRO, RLO, PDF, BN, WS?"""
    def IS_EXPLICIT_OR_SEPARATOR_OR_BN_OR_WS((p)):
        """Is explicit or separator or BN or WS: LRE, RLE, LRO, RLO, PDF, BS, SS, BN, WS?"""
    def IS_PRIVATE((p)):
        """Is private-use type for application?"""
    def CHANGE_NUMBER_TO_RTL((p)):
        """changes numbers to RTL: EN,AN -> RTL."""
    def EXPLICIT_TO_OVERRIDE_DIR((p)):
        """overrides status of an explicit mark: LRO,LRE->LTR, RLO,RLE->RTL, otherwise->ON."""
    def WEAK_PARAGRAPH((p)):
        """weakens type for paragraph fallback purposes: LTR->WLTR, RTL->WRTL."""
    def IS_JOINING_TYPE_U((p)):
        """nUn-joining"""
    def IS_JOINING_TYPE_R((p)):
        """Right-joining"""
    def IS_JOINING_TYPE_D((p)):
        """Dual-joining"""
    def IS_JOINING_TYPE_C((p)):
        """join-Causing"""
    def IS_JOINING_TYPE_L((p)):
        """Left-joining"""
    def IS_JOINING_TYPE_T((p)):
        """Transparent"""
    def IS_JOINING_TYPE_G((p)):
        """iGnored"""
    def IS_JOINING_TYPE_RC((p)):
        """Right join-Causing"""
    def IS_JOINING_TYPE_LC((p)):
        """Left join-Causing"""
    def JOINS_RIGHT((p)):
        """Joins to right: R, D, C?"""
    def JOINS_LEFT((p)):
        """Joins to left: L, D, C?"""
    def ARAB_SHAPES((p)):
        """May shape: R, D, L, T?"""
    def IS_JOIN_SKIPPED((p)):
        """Is skipped in joining: T, G?"""
    def IS_JOIN_BASE_SHAPES((p)):
        """Is base that will be shaped: R, D, L?"""
    def JOINS_PRECEDING_MASK((level)):
    def JOINS_FOLLOWING_MASK((level)):
    def JOIN_SHAPE((p)):

class Reordering:
    """convenience class for reordering elements of a sequence."""
    def __init__((self, length, elt_func)):
        """length is the number of elements, and elt_func is a function which, given each input index, returns ..."""
    def inverse((self)):
        """returns the inverse of this Reordering."""
    def __len__((self)):
    def apply((self, seq, offset=0)):
        """applies the Reordering to the specified sequence (bytes, list, string, tuple) beginning at the speci..."""
    def to_ct((self)):
        """returns the indexes as a ctypes array of FRIBIDI.StrIndex values."""
    def __repr__((self)):

class ReorderLine:
    """convenience wrapper for a common use case: reorder a line of text and extract the embedding runs. In..."""
    def __init__((self, text_line, base_dir, flags=FRIBIDI.FLAGS_DEFAULT)):
    def each_embedding_run((self, vis_order)):
        """generator function which yields in turn each contiguous run of the string line which has the same em..."""

def seq_to_ct((seq, ct_type, conv=None)):
    """extracts the elements of a Python sequence value into a ctypes array of type ct_type, optionally app..."""

def conv((x)):

def LEVEL_IS_RTL((lev)):
    """Is right-to-left level?"""

def LEVEL_TO_DIR((lev)):
    """returns the bidi type corresponding to the direction of the level number."""

def DIR_TO_LEVEL((dir)):
    """returns the minimum level of the direction, 0 for FRIBIDI.TYPE_LTR and1 for FRIBIDI.TYPE_RTL and FRI..."""

def IS_RTL((p)):
    """Is right to left: RTL, AL, RLE, RLO?"""

def IS_ARABIC((p)):
    """Is arabic: AL, AN?"""

def IS_STRONG((p)):
    """Is strong?"""

def IS_WEAK((p)):
    """Is weak?"""

def IS_NEUTRAL((p)):
    """Is neutral?"""

def IS_SENTINEL((p)):
    """Is sentinel?"""

def IS_LETTER((p)):
    """Is letter: L, R, AL?"""

def IS_NUMBER((p)):
    """Is number: EN, AN?"""

def IS_NUMBER_SEPARATOR_OR_TERMINATOR((p)):
    """Is number separator or terminator: ES, ET, CS?"""

def IS_SPACE((p)):
    """Is space: BN, BS, SS, WS?"""

def IS_EXPLICIT((p)):
    """Is explicit mark: LRE, RLE, LRO, RLO, PDF?"""

def IS_SEPARATOR((p)):
    """Is text separator: BS, SS?"""

def IS_OVERRIDE((p)):
    """Is explicit override: LRO, RLO?"""

def IS_LTR_LETTER((p)):
    """Is left to right letter: LTR?"""

def IS_RTL_LETTER((p)):
    """Is right to left letter: RTL, AL?"""

def IS_ES_OR_CS((p)):
    """Is ES or CS: ES, CS?"""

def IS_EXPLICIT_OR_BN((p)):
    """Is explicit or BN: LRE, RLE, LRO, RLO, PDF, BN?"""

def IS_EXPLICIT_OR_BN_OR_NSM((p)):
    """Is explicit or BN or NSM: LRE, RLE, LRO, RLO, PDF, BN, NSM?"""

def IS_EXPLICIT_OR_BN_OR_WS((p)):
    """Is explicit or BN or WS: LRE, RLE, LRO, RLO, PDF, BN, WS?"""

def IS_EXPLICIT_OR_SEPARATOR_OR_BN_OR_WS((p)):
    """Is explicit or separator or BN or WS: LRE, RLE, LRO, RLO, PDF, BS, SS, BN, WS?"""

def IS_PRIVATE((p)):
    """Is private-use type for application?"""

def CHANGE_NUMBER_TO_RTL((p)):
    """changes numbers to RTL: EN,AN -> RTL."""

def EXPLICIT_TO_OVERRIDE_DIR((p)):
    """overrides status of an explicit mark: LRO,LRE->LTR, RLO,RLE->RTL, otherwise->ON."""

def WEAK_PARAGRAPH((p)):
    """weakens type for paragraph fallback purposes: LTR->WLTR, RTL->WRTL."""

def IS_JOINING_TYPE_U((p)):
    """nUn-joining"""

def IS_JOINING_TYPE_R((p)):
    """Right-joining"""

def IS_JOINING_TYPE_D((p)):
    """Dual-joining"""

def IS_JOINING_TYPE_C((p)):
    """join-Causing"""

def IS_JOINING_TYPE_L((p)):
    """Left-joining"""

def IS_JOINING_TYPE_T((p)):
    """Transparent"""

def IS_JOINING_TYPE_G((p)):
    """iGnored"""

def IS_JOINING_TYPE_RC((p)):
    """Right join-Causing"""

def IS_JOINING_TYPE_LC((p)):
    """Left join-Causing"""

def JOINS_RIGHT((p)):
    """Joins to right: R, D, C?"""

def JOINS_LEFT((p)):
    """Joins to left: L, D, C?"""

def ARAB_SHAPES((p)):
    """May shape: R, D, L, T?"""

def IS_JOIN_SKIPPED((p)):
    """Is skipped in joining: T, G?"""

def IS_JOIN_BASE_SHAPES((p)):
    """Is base that will be shaped: R, D, L?"""

def JOINS_PRECEDING_MASK((level)):

def JOINS_FOLLOWING_MASK((level)):

def JOIN_SHAPE((p)):

def str_to_chars((s)):
    """returns the characters of the Python string s as a ctypes array of FRIBIDI.Char."""

def chars_to_str((s)):
    """returns the characters of a ctypes array of FRIBIDI.Char as a Python string."""

def get_unicode_version(()):
    """returns the supported Unicode version."""

def get_bidi_type((ch)):
    """returns the bidi type of a character as defined in Table 3.7\nBidirectional Character Types of the U..."""

def get_bidi_types((s)):
    """finds the bidi types of an string of characters. See\nget_bidi_type() for more information about the..."""

def get_bidi_type_name((t)):
    """returns the bidi type name of a character type.\n\nThe type names are the same as ones defined in Ta..."""

def get_par_direction((bidi_types)):
    """finds the base direction of a single paragraph,\nas defined by rule P2 of the Unicode Bidirectional ..."""

def get_par_embedding_levels((bidi_types, pbase_dir)):
    """finds the bidi embedding levels of a single paragraph,\nas defined by the Unicode Bidirectional Algo..."""

def __init__((self, length, elt_func)):
    """length is the number of elements, and elt_func is a function which, given each input index, returns ..."""

def identity((celf, length)):
    """constructs an identity Reordering of the specified length. Instead of an integer, you can pass a seq..."""

def from_seq((celf, seq)):
    """constructs a Reordering taking its indexes from the specified sequence. Besides a list or tuple, you..."""

def inverse((self)):
    """returns the inverse of this Reordering."""

def __len__((self)):

def apply((self, seq, offset=0)):
    """applies the Reordering to the specified sequence (bytes, list, string, tuple) beginning at the speci..."""

def result_convert((l)):

def to_ct((self)):
    """returns the indexes as a ctypes array of FRIBIDI.StrIndex values."""

def __repr__((self)):

def reorder_line((
    flags, bidi_types, line_offset, base_dir, embedding_levels, logical_str, map=None
)):
    """reorders the characters in a line of text from logical to\nfinal visual order. This function impleme..."""

def get_joining_type((ch)):
    """returns the joining type of a character as defined in Table\n8-2 Primary Arabic Joining Classes of t..."""

def get_joining_types((s)):
    """finds the joining types of an string of characters. See\nfribidi_get_joining_type for more informati..."""

def get_joining_type_name((j)):
    """returns the joining type name of a joining type. The type names are\nthe same as ones defined in Tab..."""

def join_arabic((bidi_types, embedding_levels, ar_props)):
    """does the Arabic joining algorithm. Means, given Arabic\njoining types of the characters in ar_props,..."""

def get_mirror_char((ch)):
    """finds the mirrored equivalent of a character as defined in\nthe file BidiMirroring.txt of the Unicod..."""

def shape_mirroring((embedding_levels, string)):
    """replaces mirroring characters on right-to-left embeddings in\nstring with their mirrored equivalent ..."""

def shape_arabic((flags, embedding_levels, ar_props, string)):
    """does Arabic shaping\n\nThe actual shaping that is done depends on the flags set. Only flags\nstartin..."""

def shape((flags, embedding_levels, ar_props, string)):
    """does all shaping work that depends on the resolved embedding\nlevels of the characters. Currently it..."""

def charset_to_unicode((char_set, s_bytes)):
    """converts a bytes value from a character set, to a Unicode string."""

def unicode_to_charset((char_set, us)):
    """converts a Unicode string to a bytes value in another character set."""

def parse_charset((s)):
    """parses character set name\n\nReturns: The character set named s, or FRIBIDI.CHAR_SET_NOT_FOUND if th..."""

def char_set_name((char_set)):

def char_set_title((char_set)):

def char_set_desc((char_set)):

def remove_bidi_marks((
    string, positions_to_this=None, position_from_this_list=None, embedding_levels=None
)):
    """removes the bidi and boundary-neutral marks out of a string\nand the accompanying lists. It implemen..."""

def log2vis((
    string,
    pbase_dir,
    want_positions_L_to_V=False,
    want_positions_V_to_L=False,
    want_embedding_levels=False,
)):
    """converts the logical input string to the visual output\nstrings as specified by the Unicode Bidirect..."""

def each_embedding_run((vis_line, embedding_levels, vis_order)):
    """Generator function which yields in turn each contiguous run of the string vis_line (previously reord..."""

def __init__((self, text_line, base_dir, flags=FRIBIDI.FLAGS_DEFAULT)):

def each_embedding_run((self, vis_order)):
    """generator function which yields in turn each contiguous run of the string line which has the same em..."""


# File: /Users/adam/Developer/vcs/github.twardoch/pub/pybidi/setup.py
# Language: python

import distutils.core


</documents>